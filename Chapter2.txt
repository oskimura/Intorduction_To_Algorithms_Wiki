* 演習
** 演習2.1-3
この問題は走査済みの配列にxと同じ値が入っていないことを帰納的に証明することがポイントだと思います

>|
linear-search(A,x)
	result <- 0
       	i <- 1
       	while i < len[A] かつ x <> A[i]
      	      i=i+1
      	if i <= len[A] then result <- i
|<


というコードを考えた場合
>|
Aはnullでは無い事とAの中にxが二個以上存在した場合に任意のインデックスを返していい事にする
resultに入ってる値は「見つかった場合はそのインデックス /\ 見つらなかった場合は0」とする

- 初期条件：
	プログラムの二行目の段階で resultには0が代入されている。
	この時点では探索は行われておらず、もちろん値は見つかっていないので、
 	０であることは条件を満たしている。
- ループ不変条件：
	ループ不変条件は、配列の添字を表現している変数iが配列のサイズを超えないこと、
	と探索済みの配列にxと同じ値が存在していないことである
        まず最初にループを実行する前はこの条件を満たしている。
	次に最初にループを実行する段階で配列が空ならばループは一度も実行されず、もちろんｘと一致する値も見つかっていない。
	配列が空ではない場合は、ループが実行される。値が見つかれば、変数iには見つかった配列のインデックスが入っている。見つからなければ、配列のサイズを超えるまでインデックスの更新が行われている。
	次のループに移る段階では、xと同じ値は見つかっておらずかiは配列の長さを超えていない
- ループ終了条件:
	iにxが見つかった配列のインデックスが入っているまたはiが配列のサイズを超えていない
|<

** 演習2.1-4
>|
<入力> A,Bという二つのビットによる配列を受け取り、
<出力> その和の配列を出力する
|<
とりあえず、Pythonで実装してみました。こんな回答で大丈夫か？
>|python|
def harfAdder(a, b):
    s = a ^ b
    c = a & b
    return (c,s)

def fullAdder(a,b,x):
    (c1, s1) = harfAdder(a,b)
    (c2, s2) = harfAdder(s1,x)
    return ((c1|c2),s2)

def plus(seq1, seq2):
    seq1.reverse()
    seq2.reverse()
    c = 0
    n = len(seq1)
    i = 0
    results = []
    while i<n :
        a = seq1[i]
        b = seq2[i]
        (c1,s) = fullAdder(a,b,c)
        c = c1
        print c
        results.append(s)
        i=i+1
    results.append(c)
    results.reverse()
    return results
||<

* 2.3 アルゴリズムの設計 
MergeSortを例にとって再帰的アルゴリズムの設計、証明、解析を行っています。
[http://www.sitmo.com/gg/latex/latex2png.2.php?z=100&eq=%20%20f(n)%20%3D%20\left\{%20\begin{array}{ll}%0A%20%20\theta(1)%20%26%20n%20\leq%20c%20\\%20%20%20%20%0A%20%20aT(n/b)%2BD(n)%2BC(n)%20%26%20otherwise%20\\%0A%20%20\end{array}%20\right.%0A:title=tex]

[tex:
  f(n) = \left\{ \begin{array}{ll}
  \theta(1) & n \leq c \\    
  aT(n/b)+D(n)+C(n) & otherwise \\
  \end{array} \right.
]



** Merge
ちなみにこのMerge処理は旧版だと演習になっていてこの擬似コードは載っていなかった(あとMergeSortのあたりはluaで実装)
>|lua|
function merge(A,p,q,r)
   n1 = q-p+1
   n2 = r-q
   L = {}
   R = {}
   print("n1",n1,"n2",n2)

   for i=1, n1 do
      L[i] = A[p+i-1]
   end
   for j=1, n2 do
      R[j] = A[q+j]
   end

   L[n1+1] = 0xffff
   R[n2+1] = 0xffff
   i = 1
   j = 1

   for k=p, r do
      print(i,j,k)
      if L[i] <= R[j] then

	 A[k] = L[i]
	 i = i+1
      else

	 A[k] = R[j]
	 j = j+1
      end
   end
   return A
end
||<

** MegerSort
>|lua|
function mergeSort(A,p,r)
   if p<r then
      q = math.floor((p+r)/2)
      mergeSort(A,p,q)
      mergeSort(A,q+1,r)
      merge1(A,p,q,r)
   end
   return A
end
||<

*演習問題
** 演習2.3-1
実はこれ旧版の方には絵が載ってる
** 演習2.3-2
>|lua|
function merge1(A,p,q,r)
   n1 = q-p+1
   n2 = r-q
   L = {}
   R = {}
   for i=1, n1 do
      L[i] = A[p+i-1]
   end
   for j=1, n2 do
      R[j] = A[q+j]
   end

   i = 1
   j = 1

   for k=p, r do
      if  j>n2 then
	 A[k] = L[i]
	 i = i+1
      elseif i>n1 then
	 A[k] = R[j]
	 j = j+1	    
      elseif (L[i] <= R[j] ) then
	 A[k] = L[i]
	 i = i+1
      elseif i>=n1 or L[i] > R[j]  then
	 A[k] = R[j]
	 j = j+1
      end
   end
   return A
end
||<

** 演習2.3-3
nが2の冪乗の時
[http://www.sitmo.com/gg/latex/latex2png.2.php?z=100&eq=%20%20T(n)%20%3D%20\left\{%20\begin{array}{ll}%0A%20%202%20%26%20n%20%3D%202%20\\%20%20%20%20%0A%20%202T(n/2)%2Bn%20%26%20k%3E1,%20n%3D2^k%20\\%0A%20%20\end{array}%20\right.:tex]
[tex:
  T(n) = \left\{ \begin{array}{ll}
  2 & n = 2 \\    
  2T(n/2)+n & k>1, n=2^k \\
  \end{array} \right.
]	
の解がT(n) = n*lg(n) であることを証明
>|
T(n)==2*lg(2)についてn=2^(k-1)について等しければ
T(n)==2*lg(2)についてn=2^(k)について等しいと仮定する
- 基底条件について証明
	2^1=n=2の時はT(2)=2である 2*lg(2)=２であり等しい
- 次にその他の場合について
	T(n)==2*lg(n)についてn=2^(2)=4とした場合、n=k^(2-1)のとき2=2^(2-1)なる
	2^(1+1)=4の時はT(4)の場合2*2+4=8となり 4*lg(4)=8であり等しい
|<
う〜んこんな答えで大丈夫か？
ここでいってる証明ってWell-Foundな性質を用いて証明するんだよね。

** 演習2.3-4
再帰版insertion Sortについて実行時間を漸化式で記述する
