

この問題は走査ずみの配列にxと同じ値が入っていないことを帰納的に証明することがポイントだと思います

linear-search(A,x)
	result <- 0
       	i <- 1
       	while i < len[A] かつ x <> A[i]
      	      i=i+1
      	if i <= len[A] then result <- i
   

というコードを考えたとき
Aはnullでは無い事とAの中にxが二個以上存在した場合に任意のインデックスを返していい事にする
resultに入ってる値は「見つかった場合はそのインデックス /\ 見つらなかった場合は0」とする
初期条件：
	プログラムの二行目の段階で resultには0が代入されている。
	この時点では探索は行われておらず、もちろん値は見つかっていないので、
 	０であることは条件そ満たしている。
ループ不変条件：
	ループ不変条件は、配列の添字を表現しているiが配列のサイズを超えないこと、
	と探索済みの配列にxと同じ値が存在していないことである
        まず最初にループを実行する前はこの条件を満たしている。
	次に最初にループを実行する段階で配列が空ならばループは一度も実行されず、もちろんｘと一致する値も見つかっていない。
	配列が空ではない場合は、ループが実行される。値が見つかれば、変数iには見つかった配列のインデックスが入っている。見つからなければ、配列のサイズを超えるまでインデックスの更新が行われている。
	次のループに移る段階では、xと同じ値は見つかっておらずかiは配列の長さを超えていない
ループ終了条件:
	iにxが見つかった配列のインデックスが入っているまたはiが配列のサイズを超えていない



add-binary-string(A,B)
	length <- 0
	if len[A] < len[B] 
	   length <- len[A]
	else
	   length <- len[b]
